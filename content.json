{"meta":{"title":"Zinc0x1E's Blog","subtitle":"","description":"","author":"Zinc0x1E","url":"https://zinc0x1E.github.io","root":"/"},"pages":[{"title":"tags","date":"2020-12-20T14:11:32.000Z","updated":"2021-03-13T08:32:27.341Z","comments":true,"path":"about/index.html","permalink":"https://zinc0x1e.github.io/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-20T14:11:32.000Z","updated":"2021-03-13T08:32:27.342Z","comments":true,"path":"archives/index.html","permalink":"https://zinc0x1e.github.io/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-20T14:12:37.000Z","updated":"2021-03-13T08:32:27.343Z","comments":true,"path":"categories/index.html","permalink":"https://zinc0x1e.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-20T14:11:32.000Z","updated":"2021-03-13T08:32:27.344Z","comments":true,"path":"notes-list/index.html","permalink":"https://zinc0x1e.github.io/notes-list/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-20T14:11:32.000Z","updated":"2021-03-13T08:32:27.345Z","comments":true,"path":"posts-list/index.html","permalink":"https://zinc0x1e.github.io/posts-list/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-20T14:12:37.000Z","updated":"2021-03-13T08:32:27.346Z","comments":true,"path":"tags/index.html","permalink":"https://zinc0x1e.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Redis 数据类型总结 - Intro","slug":"summary-of-redis-data-types-01","date":"2021-03-09T10:10:02.000Z","updated":"2021-03-13T08:32:27.324Z","comments":true,"path":"2021/03/09/summary-of-redis-data-types-01/","link":"","permalink":"https://zinc0x1e.github.io/2021/03/09/summary-of-redis-data-types-01/","excerpt":"","text":"Redis 数据类型总结 - Intro 本篇笔记主要针对《Redis 设计与实现》第八章，亦参考了包括其他章节和 Redis 官方文档在内的一些其他资料，完整参考资料详见文末“参考资料”部分。 Prerequisite: Redis 使用 C 语言实现 本文基于 Redis 6.2 进行分析，会与《Redis 设计与分析》第二版略有偏差。 Redis 类型与编码 Redis 使用对象存储 Key 和 Value 每当创建 KV 对时，Redis 会至少创建两个对象，其中一个键对象，另一个是值对象 Redis 中的对象由 redisObject 结构体表示 对应源码位于 server.h 123456789typedef struct redisObject &#123; unsigned type:4; unsigned encoding:4; unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or * LFU data (least significant 8 bits frequency * and most significant 16 bits access time). */ int refcount; void *ptr; // 指向底层数据结构的指针&#125; robj; 类型 （对应 robj.type 字段） Redis 中现有 7 种类型 string list set zset Sorted set hash module 一种内部类型，type 为 module 的对象由 Redis 模块直接管理 不能作为值对象类型 后文不具体展开讨论此类型 stream 不能作为值对象类型 后文不具体展开讨论此类型 Redis 的键对象总是一个 string 类对象 当称呼一个键是“xx 键”时，意为这个键所对应的值是 xx 类型 e.g. “列表键” 指这个键所对应的值是列表类型 1234567891011121314151617181920/* The actual Redis Object */#define OBJ_STRING 0 /* String object. */#define OBJ_LIST 1 /* List object. */#define OBJ_SET 2 /* Set object. */#define OBJ_ZSET 3 /* Sorted set object. */#define OBJ_HASH 4 /* Hash object. *//* The &quot;module&quot; object type is a special one that signals that the object * is one directly managed by a Redis module. In this case the value points * to a moduleValue struct, which contains the object value (which is only * handled by the module itself) and the RedisModuleType struct which lists * function pointers in order to serialize, deserialize, AOF-rewrite and * free the object. * * Inside the RDB file, module types are encoded as OBJ_MODULE followed * by a 64 bit module type ID, which has a 54 bits module-specific signature * in order to dispatch the loading to the right module, plus a 10 bits * encoding version. */#define OBJ_MODULE 5 /* Module object. */#define OBJ_STREAM 6 /* Stream object. */ 编码（对应 robj.encoding 字段） robj.ptr 指向作为数据内容 robj.encoding 为数据内容的存储结构类型 1234567891011121314/* Objects encoding. Some kind of objects like Strings and Hashes can be * internally represented in multiple ways. The &#x27;encoding&#x27; field of the object * is set to one of this fields for this object. */#define OBJ_ENCODING_RAW 0 /* Raw representation */ /* 对应 SDS，底层是 char[]，可以视作是 raw bytes */#define OBJ_ENCODING_INT 1 /* Encoded as integer */ /* 底层是 long 型整数 */#define OBJ_ENCODING_HT 2 /* Encoded as hash table */ /* 《Redis 设计与实现》中称作“字典” */#define OBJ_ENCODING_ZIPMAP 3 /* Encoded as zipmap */#define OBJ_ENCODING_LINKEDLIST 4 /* No longer used: old list encoding. */ /* 双端链表 */#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */ /* 压缩列表 */#define OBJ_ENCODING_INTSET 6 /* Encoded as intset */#define OBJ_ENCODING_SKIPLIST 7 /* Encoded as skiplist */ /* 《Redis 设计与实现》中称作“跳跃表” */#define OBJ_ENCODING_EMBSTR 8 /* Embedded sds string encoding */#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */ 参考资料 黄健宏，《Redis 设计与实现》第二版第八章 https://github.com/redis/redis/blob/6.2/src","categories":[{"name":"database","slug":"database","permalink":"https://zinc0x1e.github.io/categories/database/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zinc0x1e.github.io/tags/Redis/"},{"name":"源码解析","slug":"源码解析","permalink":"https://zinc0x1e.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"字符串匹配算法笔记","slug":"note-of-string-searching-algo","date":"2021-03-09T10:10:02.000Z","updated":"2021-03-13T08:32:27.324Z","comments":true,"path":"2021/03/09/note-of-string-searching-algo/","link":"","permalink":"https://zinc0x1e.github.io/2021/03/09/note-of-string-searching-algo/","excerpt":"","text":"字符串匹配算法总结 本文为 CLRS 3rd ed. 第 32 章内容的总结概括，同时也总结概括了一些其他优秀的 String-matching 算法，完整参考资料详见文末“参考资料”部分。 字符串匹配算法（String-matching algorithm），a.k.a 字符串搜索算法（String-searching algorithm）是一类重要的字符串算法。它要解决的问题是如何在一个长字符串中，找到另一个短字符串出现的位置。 问题描述 给定一个长为 nnn 的字符串 T[1..n]T[1..n]T[1..n]（the text）和一个长为 m(m≤n)m (m \\le n)m(m≤n) 的字符串 P[1..m]P[1..m]P[1..m]（the pattern），我们需要确定 1. HHH 中是否含有 EEE，2. 若含有，HHH 中的 EEE 的位置在哪里。 有时 the text TTT 会被称为 the “haystack”，the pattern PPP 会被称为 the “neddle” TTT 和 PPP 定义在一个有限字母集（alphabet）Σ\\SigmaΣ 上。 我们称 PPP 以 sss 的位移（shift）出现在 TTT 中 或 PPP 出现在 TTT 的第 s+1s+1s+1 个位置意味着： 0≤s≤n−m0 \\le s \\le n - m0≤s≤n−m，且 T[s+1..s+m]=P[1..m]T[s+1..s+m] = P[1..m]T[s+1..s+m]=P[1..m] 若 PPP 在 TTT 中以位移 sss 出现，则称 sss 为有效位移，否则 sss 就为无效位移。 于是，问题就可以形式化的描述为：给定 TTT，找出所有 PPP 的有效位移。 Notation &amp; Terminology 字符串及字符串运算相关 Σ∗\\Sigma^*Σ∗ —— 由 Σ\\SigmaΣ 中的字符组成的所有可能的字符串构成的集合 ϵ\\epsilonϵ —— Empty string，空串 / 空字符串，长度为 000 的字符串 ∣x∣\\left| x \\right|∣x∣ —— 字符串 xxx 的长度 xyxyxy —— The concatenation of xxx and yyy，字符串 xxx 和 yyy 的连接 字符串关系相关 w⊏xw \\sqsubset xw⊏x —— www 是 xxx 的前缀（prefix） w⊐xw \\sqsupset xw⊐x —— www 是 xxx 的后缀（surfix） ⊏\\sqsubset⊏ 和 ⊐\\sqsupset⊐ 运算有如下性质 w⊏x⟹∣w∣≤∣x∣w \\sqsubset x \\Longrightarrow |w| \\le |x|w⊏x⟹∣w∣≤∣x∣；w⊐x⟹∣w∣≤∣x∣w \\sqsupset x \\Longrightarrow |w| \\le |x|w⊐x⟹∣w∣≤∣x∣ x⊐y ⟺ xa⊐yax \\sqsupset y \\iff xa \\sqsupset yax⊐y⟺xa⊐ya ⊏\\sqsubset⊏ 和 ⊐\\sqsupset⊐ 都具有传递性 Overlapping-suffix lemma 给定字符串 x,y,zx,y,zx,y,z，x⊏z∧y⊏zx \\sqsubset z \\land y \\sqsubset zx⊏z∧y⊏z。 当 ∣x∣≤∣y∣|x| \\le |y|∣x∣≤∣y∣ 时，x⊐yx \\sqsupset yx⊐y； 当 ∣x∣≥∣y∣|x| \\ge |y|∣x∣≥∣y∣ 时，x⊏yx \\sqsubset yx⊏y； 当 ∣x∣=∣y∣|x| = |y|∣x∣=∣y∣ 时，x=yx = yx=y。 The Naive String-Matching Algorithm | 暴力法 最朴素的暴力算法 12345678Naive-String-Matching-Algo(T, P): n :&#x3D; |T| m :&#x3D; |P| for s from 0 to n - m: | if P[1..m] &#x3D; T[s+1..s+m] | | Match! | - - 时间复杂度分析 for 循环执行 n−m+1n-m+1n−m+1 趟，每趟内部检查 P[1..m]=?T[s+1..s+m]P[1..m] =? T[s+1..s+m]P[1..m]=?T[s+1..s+m] 时会发生 O(m)O(m)O(m) 次比较，故整体时间复杂度 O((n−m+1)m)O((n-m+1)m)O((n−m+1)m)；最差情况发生在每趟迭代都跑满了 mmm 次字符比较时，TTT 和 PPP 中的字符完全同时，此时时间复杂度为 Θ((n−m+1)m)\\Theta((n-m+1)m)Θ((n−m+1)m) 优化的方向 观察可以发现，这个算法的所需时间可以写成 $\\text{Number of Checking } \\cdot T_{Checking}\\ $，这里 Checking 是指检查 P[1..m]=? T[s+1..s+m]P[1..m] =?\\ T[s+1..s+m]P[1..m]=? T[s+1..s+m] 的过程。 那么我们的思路就很清晰了，优化暴力法的主要思路就两条： 减少 Checking 所需的时间 减少 Checking 的次数 减少 Checking 所需时间 —— The Rabin-Karp Algorithm | RK 算法 KR 算法利用了一些初等数论的知识减少了每趟循环中比较的次数。 在这个算法之中，每个字符串都会被看成一个数字，下文主要考虑这种情况：令 Σd={0,1,…,9\\Sigma_d = \\{ 0,1,\\dots,9Σd​={0,1,…,9}\\}}，任意一个 Σd∗\\Sigma_d^*Σd∗​ 中的字符串都可以被看做一个十进制数。比如 &quot;12345&quot;∈Σd∗&quot;12345&quot; \\in \\Sigma_d^*&quot;12345&quot;∈Σd∗​ 可以被看作十进制数 123451234512345。 对于任意一个字母表 Σ\\SigmaΣ，都可以将任意一个其中的字符串 s∈Σ∗s \\in \\Sigma^*s∈Σ∗ 看作一个 ∣Σ∣|\\Sigma|∣Σ∣ 进制数。 给定一个 pattern P[1..m]P[1..m]P[1..m] 和一个 text T[1..n]T[1..n]T[1..n]，令 ppp 为 P[1..m]P[1..m]P[1..m] 对应的数，tst_sts​ 为 T[s+1..s+m]T[s+1..s+m]T[s+1..s+m] 对应的数。则 P[1..m]=T[s+1..s+m] ⟺ p=tsP[1..m] = T[s+1..s+m] \\iff p = t_sP[1..m]=T[s+1..s+m]⟺p=ts​ 利用如下公式，可以在 (n−m)∗Θ(1)=Θ(n−m)=Θ(n−m+1)(n-m) * \\Theta(1) = \\Theta(n-m) = \\Theta(n-m+1)(n−m)∗Θ(1)=Θ(n−m)=Θ(n−m+1) 的时间内计算出每一个 tst_sts​（前提是算数计算的时间复杂度可以视为常数）： 去掉 tst_sts​ 的最高位，补上 ts+1t_{s+1}ts+1​ 最低位。 ts+1=∣Σ∣(ts−∣Σ∣m−1T[s+1])+T[s+m+1]t_{s+1} = |\\Sigma| (t_s - |\\Sigma|^{m-1} T[s+1]) + T[s+m+1] ts+1​=∣Σ∣(ts​−∣Σ∣m−1T[s+1])+T[s+m+1] 十进制下，即为 ts+1=10(ts−10m−1T[s+1])+T[s+m+1]t_{s+1} = 10 (t_s - 10^{m-1} T[s+1]) + T[s+m+1] ts+1​=10(ts​−10m−1T[s+1])+T[s+m+1] 注意到，计算 ppp 需要的时间是 Θ(m)\\Theta(m)Θ(m)。 因此，我们只需要 Θ(m)+Θ(n−m+1)=Θ(n)\\Theta(m) + \\Theta(n-m+1) = \\Theta(n)Θ(m)+Θ(n−m+1)=Θ(n) 的时间就能跑完整个算法。 但是，当 tst_sts​ 或 ppp 十分大时，前面算数计算时间复杂度为常数的假设就失效了。 本质上，可以将转换为 n 进制数视作是一种不会发生碰撞的哈希函数，在 RK 算法中，我们需要的只是一个 f:Σ↦Af: \\Sigma \\mapsto \\mathbb{A}f:Σ↦A（A\\mathbb{A}A 是任意一个可以在 Θ(1)\\Theta(1)Θ(1) 时间内完成比较和算数运算的类型）的哈希函数。 对于这里而言，最容易想到的做法就是 mod，即，采用 f(x)=x.toInteger mod q,x∈Σ∗∧q∈Zf(x) = x.toInteger\\ \\mathtt{mod}\\ q, x \\in \\Sigma^* \\land q \\in \\mathbb{Z}f(x)=x.toInteger mod q,x∈Σ∗∧q∈Z 的哈希函数。为了保证算数运算能在常数时间内完成，一般选取一个素数且能满足 dq&lt;Integer.MAX_VALUEdq &lt; \\mathtt{Integer.MAX\\_VALUE}dq&lt;Integer.MAX_VALUE，其中 d=∣Σ∣d = |\\Sigma|d=∣Σ∣，qqq 为我们所需的除数。 因此，我们修改公式如下： ts+1=(d(ts−T[s+1]h)+T[s+m+1])modqt_{s+1} = (d (t_s - T[s+1]h) + T[s+m+1]) \\mathtt{mod} q ts+1​=(d(ts​−T[s+1]h)+T[s+m+1])modq 其中 d=∣Σ∣,h≡dm−1 mod qd = |\\Sigma|, h \\equiv d^{m-1}\\ \\mathtt{mod}\\ qd=∣Σ∣,h≡dm−1 mod q 为素数且 dq&lt;Integer.MAX_VALUE,0≤s≤n−mdq &lt; \\mathtt{Integer.MAX\\_VALUE}, 0 \\le s \\le n - mdq&lt;Integer.MAX_VALUE,0≤s≤n−m 但是，既然选择了哈希，就要考虑碰撞。这种哈希函数确实存在碰撞的可能性，但仅当哈希值相等时，p=tsp = t_sp=ts​ 才可能发生。所以我们可以在哈希值不相等时，直接略过，在相等时用暴力法类似的方法检查。在 p=ts∧P≠T[s+1..s+m]p = t_s \\land P \\neq T[s+1..s+m]p=ts​∧P=T[s+1..s+m] 时，我们称之为一次 spurious hit。 123456789101112131415161718192021222324RK-ALGO(T, P, d, q): n :&#x3D; |T| m :&#x3D; |P| h :&#x3D; m -&gt; d ** (m-1) % q p :&#x3D; 0 t_0 :&#x3D; 0 &#x2F;&#x2F; Preprocessing for i from 1 to m: | p :&#x3D; (d * p + P[i]) % q | t_0 &#x3D; (d * t_0 + T[i]) % q - &#x2F;&#x2F; Matching for s from 0 to n-m: | if p &#x3D; t_s: | | if P[1..m] &#x3D; T[s+1..s+m] | | | Match! | | - | - | if s &lt; n - m: | | t_s+1 &#x3D; (d * ( t_s - T[s+1] * h(m)) + T[s+m+1]) % q | - - 时间复杂度分析 如上文所述，预处理 ppp 和 t0t_0t0​ 恒定需 Θ(m)\\Theta(m)Θ(m) 的时间。对于 Matching 阶段后，其最坏情况也出现在 PPP 和 TTT 实际完全相同时。这种情况下，Matching 阶段完全退化回暴力法，这部分时间复杂度为 Θ((n−m+1)m)\\Theta((n-m+1)m)Θ((n−m+1)m)。总体的最坏时间复杂度为 Θ(m)+Θ((n−m+1)m)=Θ((n−m+1)m)\\Theta(m) + \\Theta((n-m+1)m) = \\Theta((n-m+1)m)Θ(m)+Θ((n−m+1)m)=Θ((n−m+1)m)。 在实际应用场景中，通常有效位移十分少，假设有效位移数为常数 ccc。这种情况下，期望的时间复杂度仅为 Θ(m)+O((n−m+1)+cm)=Θ(m)+O(n+m)\\Theta(m) + O((n-m+1) + cm) = \\Theta(m) + O(n+m)Θ(m)+O((n−m+1)+cm)=Θ(m)+O(n+m) 更一般得，如果我们假设 x↦x.toInteger mod qx \\mapsto x.toInteger\\ \\mathtt{mod}\\ qx↦x.toInteger mod q 这个哈希函数能近乎于平均得将 Σ∗\\Sigma^*Σ∗ 分散开，那么 spurious hit 的次数就是 O(n/q)O(n/q)O(n/q)，那么期望时间复杂度就是 Θ(m)+O(n−m)+O(m(v+n/q))\\Theta(m) + O(n - m) + O(m(v + n / q))Θ(m)+O(n−m)+O(m(v+n/q))，其中 vvv 是有效位移的个数。 减少 Checking 次数 —— 自动机法 设计思路 给定 T=&quot;ababababc&quot;T = &quot;ababababc&quot;T=&quot;ababababc&quot; 和 P=&quot;ababc&quot;P = &quot;ababc&quot;P=&quot;ababc&quot;，回顾之前暴力法中我们的做法。 我们会先对 PPP 和 T[1..m]T[1..m]T[1..m] 进行 Checking。 发现不匹配后，检查 T[2..m+1]T[2..m+1]T[2..m+1]。但是，如果记忆下逐字符匹配的信息，我们是应该可以优化这个过程，跳过一些显然不可能发生匹配的情形。 为了能发现我们可以从这一次的 Checking 过程中发现声明为，让我们把视野局限到 T[1..5]T[1..5]T[1..5] 的范围内。 在暴力法中，我们会将 PPP 向后移动，逐一检查这几种情形： 观察上图可以发现，我们实际在做的事情是在逐位后移 PPP 并尝试检查 PPP 的一个前缀和 T[1..5]T[1..5]T[1..5] 的一个后缀之间是否匹配。而仅就我们的视野范围内的情况来说，只有当 PPP 的前缀和 T[1..5]T[1..5]T[1..5] 的后缀相等的情况下（上图下方两种情况），才有可能发生整个 PPP 和 TTT 的一个子串的匹配。 而且，我们应该选择的是这些既是 PPP 的前缀又是 T[1..5]T[1..5]T[1..5] 的后缀中最长的那一个，作为我们下一次匹配的起点。因为我们的视野仅局限于 [1..5][1..5][1..5]，所以如果略过上图左下角的情况，直接到右下角的位置，那么很有可能漏匹配。（考虑 T=&quot;abababc&quot;T = &quot;abababc&quot;T=&quot;abababc&quot; 的情况。） 总结概括家稍微抽象一下，我们应该要找到既是 PPP 的前缀，又是 T[k+1..k+m]T[k+1..k+m]T[k+1..k+m] 的后缀的字符串中，长度最长的那个（令这个值为 σ\\sigmaσ），并将 PPP 后移 σ−1\\sigma - 1σ−1 位（也可以说是将 TTT 前移 σ−1\\sigma - 1σ−1 位），然后开始下一次的检查。 令 σ(x)\\sigma(x)σ(x) 为既是 PPP 的前缀，又是 xxx 的后缀的字符串中最长的那个的长度，即 σ(x)={k∣Pk⊐x} \\sigma(x) = \\{k | P_k \\sqsupset x \\}\\;σ(x)={k∣Pk​⊐x}，其中 PkP_kPk​ 是 PPP 长为 kkk 的前缀。 将 TTT 看作是 一个字符一个字符 与 PPP 进行匹配的，令 qqq 为已经匹配上的字符数，T[i]T[i]T[i] 为当前正在检查的字符，那么就有 qnext=σ(T[1..i])=σ(PqT[i])q_{next} = \\sigma(T[1..i]) = \\sigma(P_q T[i]) qnext​=σ(T[1..i])=σ(Pq​T[i]) 由于已经匹配上了 qqq 个字符，所以 Pq=T[i−q..i−1]P_q = T[i-q..i-1]Pq​=T[i−q..i−1]，所以 σ(T[1..i])=σ(PqT[i])\\sigma(T[1..i]) = \\sigma(P_q T[i])σ(T[1..i])=σ(Pq​T[i]) 自动机 自动机可以用一个五元组表示 M(Q,q0,A,Σ,δ)M(Q, q_0, A, \\Sigma, \\delta)M(Q,q0​,A,Σ,δ)，分别代表状态集、起始状态、accepting 状态、输入字母表和转移函数。 ϕ:Σ∗↦Q\\phi: \\Sigma* \\mapsto Qϕ:Σ∗↦Q 且 ϕ(x)\\phi(x)ϕ(x) 是输入字符串 xxx 后自动机 MMM 所处的状态 更详细的解释此处略过。 首先先感性的认识一下如何用自动机的方式描述之前所讲的事情。 初始状态下，q=0q = 0q=0，整个自动机及输入字符串可以用下图表示： 读入一个字符 a←′a′a \\leftarrow &#x27;a&#x27;a←′a′： a=P[q+1]a = P[q+1]a=P[q+1]，故 q←q+1q \\leftarrow q + 1q←q+1： 同理，读入 ′b′&#x27;b&#x27;′b′ 后如下图上侧；再读入一个 ′a′&#x27;a&#x27;′a′ 如下图中间；再读入一个 ′b′&#x27;b&#x27;′b′ 如下图下侧： 此时，再读入 ′a′&#x27;a&#x27;′a′： ′a′≠P[5]&#x27;a&#x27; \\neq P[5]′a′=P[5]，故下一个状态是 q=Σ(P5′a′)=3q = \\Sigma(P_5 &#x27;a&#x27;) = 3q=Σ(P5′​a′)=3，故转换成如下状态： 之后的转换过程与前文一致，省略。 用形式化一些的自动机的语言来刻画，这个自动机如下图所示： Q={0,1,…,∣P∣} Q = \\{0,1,\\dots,|P|\\}\\;Q={0,1,…,∣P∣} q0=0q_0 = 0q0​=0 A=A =A= Σ\\SigmaΣ 为字母表 δ(q,a)=σ(Pqa)\\delta(q, a) = \\sigma(P_q a)δ(q,a)=σ(Pq​a) 那么整个算法就可以写成 n←∣T∣m←∣P∣q←0for i from 1 to n:q←δ(q,T[i])if q=mMatch!\\begin{aligned} &amp; n \\leftarrow |T| \\\\ &amp; m \\leftarrow |P| \\\\ &amp; q \\leftarrow 0 \\\\ &amp; \\text{for } i \\text{ from } 1 \\text { to } n: \\\\ &amp; \\qquad q \\leftarrow \\delta(q, T[i]) \\\\ &amp; \\qquad \\text{if } q = m \\\\ &amp; \\qquad \\qquad \\text{Match!} \\end{aligned} ​n←∣T∣m←∣P∣q←0for i from 1 to n:q←δ(q,T[i])if q=mMatch!​ δ\\deltaδ 的计算 接下来，我们只需要计算出 δ\\deltaδ 函数，这个算法就完成了。而 CLRS 中，作者直接给了一个暴力算法： m←∣P∣for q from 1 to m:foreach a∈Σ:k←min⁡(m,q+1)while Pk⊐Pqa:k←k−1δ(q,a)=k\\begin{aligned} &amp; m \\leftarrow |P| \\\\ &amp; \\text{for } q \\text{ from } 1 \\text { to } m: \\\\ &amp; \\qquad \\text{foreach } a \\in \\Sigma: \\\\ &amp; \\qquad \\qquad k \\leftarrow \\min(m, q + 1) \\\\ &amp; \\qquad \\qquad \\text{while } P_k \\sqsupset P_q a: \\\\ &amp; \\qquad \\qquad \\qquad k \\leftarrow k - 1 \\\\ &amp; \\qquad \\qquad \\delta(q,a) = k \\end{aligned} ​m←∣P∣for q from 1 to m:foreach a∈Σ:k←min(m,q+1)while Pk​⊐Pq​a:k←k−1δ(q,a)=k​ 但是作者们也提及，利用 KMP 算法中的一些技巧，可以将这个过程的算法复杂度优化到 O(m∣Σ∣)O(m |\\Sigma|)O(m∣Σ∣)，我们暂且采用这个复杂度。 时间复杂度分析 预处理仅有计算 δ\\deltaδ 函数一个工作，算法复杂度即为 O(m∣Sigma∣)O(m |Sigma|)O(m∣Sigma∣) 匹配阶段中，循环会迭代 nnn 次，每次迭代需要常数时间执行，故总计 Θ(n)\\Theta(n)Θ(n) 优化空间 δ\\deltaδ 的计算过程十分耗时，尽管采用了优化后的算法，也无法避免的要遍历一遍 Σ\\SigmaΣ，这在字母表非常大时（例如 utf-8）会非常非常耗时。 The Knuth-Morris-Pratt Algorithm | KMP 算法 回顾之前的自动机法，我们用很高昂的代价找到了一个 精确 的状态转移函数，那么我们有没有什么办法，牺牲一些精确性，让开销小一点呢？ 观察 q=4q=4q=4，发生不匹配时的情形： 在自动机法中，我们通过高昂的代价找到了精确的未来状态 q=3q=3q=3。但实际上，由于 T[1..4]=P4T[1..4] = P_4T[1..4]=P4​，我们可以暂时抛弃掉 TTT： （X≠′c′X \\neq &#x27;c&#x27;X=′c′） 如此，我们就应该移动 PPP，使得 &quot;abab&quot;&quot;abab&quot;&quot;abab&quot; 的某个真后缀和 PPP 的某个前缀匹配起来，即： 令 σ′(x)=max{k∣k&lt;∣x∣∧Pk⊐x} \\sigma&#x27;(x) = max\\{k | k &lt; |x| \\land P_k \\sqsupset x \\}\\;σ′(x)=max{k∣k&lt;∣x∣∧Pk​⊐x} （回忆 σ\\sigmaσ 的定义） 令 π(q)=σ′(Pq)=max{k∣k&lt;m∧Pk⊐Pq} \\pi(q) = \\sigma&#x27;(P_q) = max\\{k | k &lt; m \\land P_k \\sqsupset P_q \\}\\;π(q)=σ′(Pq​)=max{k∣k&lt;m∧Pk​⊐Pq​} 这样子，我们仅需计算 σ′(&quot;abab&quot;)\\sigma&#x27;(&quot;abab&quot;)σ′(&quot;abab&quot;)，更一般得， σ′(Pq)\\sigma&#x27;(P_q)σ′(Pq​), 即可。这大大缩减了我们的运算速度，我们不再需要遍历一遍 Σ\\SigmaΣ。 自动机法中，我们是将 TTT 和 PPP 视作两个条带，每次将 TTT 条带向前移动一格，检查新的字符。如果新的字符匹配，那么我们就让 PPP 和 TTT 同步向前移动一格。如果不匹配，则用事先计算好的最优解，将 PPP 条带调整到一个最为精准的位置继续匹配下去。 而 KMP 法中，我们同样将 TTT 和 PPP 视作条带，唯一不同的是，我们在逐渐尝试 PPP 的合适的位置，这种尝试不会像暴力法一样逐个字符去匹配，也不会像自动机法那样一步到位，而是折中地找一个合理的、差不多合适的解。这个“差不多合适”就是指这里的 π(q)\\pi(q)π(q)。 KMP 算法就可以用如下伪代码表示： n←∣T∣m←∣P∣q←0for i from 1 to n:while q&gt;0∧P[q+1]≠T[i]:q←π[q]if T[i]=P[q+1]:q←q+1if q=m:Match!q←π[q]\\begin{aligned} &amp; n \\leftarrow |T| \\\\ &amp; m \\leftarrow |P| \\\\ &amp; q \\leftarrow 0 \\\\ &amp; \\text{for } i \\text{ from } 1 \\text { to } n: \\\\ &amp; \\qquad \\text{while } q &gt; 0 \\land P[q+1] \\neq T[i]: \\\\ &amp; \\qquad \\qquad q \\leftarrow \\pi[q] \\\\ &amp; \\qquad \\qquad \\text{if } T[i] = P[q+1]:\\\\ &amp; \\qquad \\qquad \\qquad q \\leftarrow q + 1\\\\ &amp; \\qquad \\qquad \\text{if } q = m: \\\\ &amp; \\qquad \\qquad \\qquad \\text{Match!} \\\\ &amp; \\qquad \\qquad \\qquad q \\leftarrow \\pi[q] \\\\ \\end{aligned} ​n←∣T∣m←∣P∣q←0for i from 1 to n:while q&gt;0∧P[q+1]=T[i]:q←π[q]if T[i]=P[q+1]:q←q+1if q=m:Match!q←π[q]​ π\\piπ 的计算 我们可以将 PPP 分成若干段： Pk P[k+1..q−2k] Pk P[q] P[q+1..m]P_k \\ P[k+1..q-2k] \\ P_k \\ P[q] \\ P[q+1..m] Pk​ P[k+1..q−2k] Pk​ P[q] P[q+1..m] 假设 Pk=π(q−1)P_k = \\pi(q-1)Pk​=π(q−1)（PkP_kPk​ 既是 Pq−1P_{q-1}Pq−1​ 的后缀，也是 PPP 的前缀），则当 P[q]=P[k]P[q] = P[k]P[q]=P[k] 时，显然 π(q)=k+1\\pi(q) = k + 1π(q)=k+1。而当 P[q]≠P[k]P[q] \\neq P[k]P[q]=P[k] 时，可以令 k:=π(k)k := \\pi(k)k:=π(k) 将 PkP_kPk​ 的范围缩小，直到 k=0k = 0k=0 或者出现 P[q]=P[k]P[q] = P[k]P[q]=P[k] 的情况。 所以计算 π\\piπ 的过程为： m←∣P∣π[1]←0k←0for q from 2 to m:while k&gt;0∧P[k+1]≠P[q]k←π[k]if P[k+1]=P[q]k←k+1π[q]←k\\begin{aligned} &amp; m \\leftarrow |P| \\\\ &amp; \\pi[1] \\leftarrow 0 \\\\ &amp; k \\leftarrow 0 \\\\ &amp; \\text{for } q \\text{ from } 2 \\text{ to } m: \\\\ &amp; \\qquad \\text{while } k &gt; 0 \\land P[k+1] \\neq P[q] \\\\ &amp; \\qquad \\qquad k \\leftarrow \\pi[k] \\\\ &amp; \\qquad \\text{if } P[k+1] = P[q] \\\\ &amp; \\qquad \\qquad k \\leftarrow k + 1 \\\\ &amp; \\qquad \\pi[q] \\leftarrow k \\\\ \\end{aligned} ​m←∣P∣π[1]←0k←0for q from 2 to m:while k&gt;0∧P[k+1]=P[q]k←π[k]if P[k+1]=P[q]k←k+1π[q]←k​ 时间复杂度分析 π\\piπ 函数计算的时间为 Θ(m)\\Theta(m)Θ(m) Matching 阶段所需的时间依然为 Θ(n)\\Theta(n)Θ(n) 总结 算法 预处理阶段时间复杂度 匹配阶段平均时间复杂度 匹配阶段最坏情况时间复杂度 暴力法 0 O((n−m+1)m)O((n-m+1)m)O((n−m+1)m) Θ((n−m+1)m)\\Theta((n-m+1)m)Θ((n−m+1)m) KR 算法 Θ(m)\\Theta (m)Θ(m) O(n−m)+O(m(v=n/q))O(n-m) + O(m(v = n / q))O(n−m)+O(m(v=n/q)) Θ((n−m+1)m)\\Theta((n-m+1)m)Θ((n−m+1)m) 自动机法 O(m∥Σ∥)O(m \\|\\Sigma\\|)O(m∥Σ∥) Θ(n)\\Theta(n)Θ(n) Θ(n)\\Theta(n)Θ(n) KMP 算法 Θ(m)\\Theta(m)Θ(m) Θ(n)\\Theta(n)Θ(n) Θ(n)\\Theta(n)Θ(n) 参考资料 arthur.dy.lee. (2018, July 22). 字符串匹配算法综述. CSDN. https://blog.csdn.net/paincupid/article/details/81159320Cormen, T. H., Leiserson, C. E., Rivest, R. L., &amp; Stein, C. (2009). Introduction to Algorithms, 3rd Edition (The MIT Press) (3rd ed.). MIT Press. Wikipedia contributors. (2021, February 14). String-searching algorithm. Wikipedia. https://en.wikipedia.org/wiki/String-searching_algorithm","categories":[{"name":"algorithm","slug":"algorithm","permalink":"https://zinc0x1e.github.io/categories/algorithm/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://zinc0x1e.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"Method Chaining Pros & Cons","slug":"method-chaining-pros-and-cons","date":"2021-02-11T02:15:02.000Z","updated":"2021-03-13T08:32:27.323Z","comments":true,"path":"2021/02/11/method-chaining-pros-and-cons/","link":"","permalink":"https://zinc0x1e.github.io/2021/02/11/method-chaining-pros-and-cons/","excerpt":"","text":"Method Chaining – Pros &amp; Cons 什么是 Method Chaining Method chaining（方法链，是一种 API 设计方式）。这种设计方式中，每个返回值本来应当为 void 的方法返回调用者本身而不是 void，以使得调用可以链式地延续下去。 使用这种风格设计的 API 被称作 fluent interface。 这种设计风格有时也被称为： named parameter idion（命名参数惯用法）（似乎在 C++ 社区中用的比较多） pipline Example 简单来说，就是一种支持以下这种链式操作的一种在设计 API 时的惯用技巧（也可以说是一种语法糖）。 12345list.add(1) .add(2) .add(2) .add(5);// [1, 2, 2, 5] 在 Java 的 stream API 和 JavaScript 的 Array 的某些方法使用了这个设计方式。 1234somethings .filter(x =&gt; x.count &gt; 10) .sort((a, b) =&gt; a.count - b.count) .map(x =&gt; x.name) C++ 中也有这个语法糖： 12345std::cout &lt;&lt; b &lt;&lt; c;// 这等价于std::cout &lt;&lt; b;std::cout &lt;&lt; c; Pros &amp; Cons 尽管 method chaining 的好坏是一件非常主观的事情，过度深究下去就会变成类似于 &#123;&#125; 位置的宗教战争，但我还是尽可能的列举一些较多人认可的、多少有一些实质性影响的观点。这也是为什么可能在 Pros 和 Cons 中看到相反观点的原因。 Pros 有时候，method chaining 是非常自然的，因为很多方法的返回值是另一个对象 123List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();// 返回 dogs 中第一只狗距离 (0, 0) 的距离double dist = dogs.get(0).getPosition().distanceFrom(0, 0); 某些情况下，可以使代码更加简洁，同时也不会牺牲多少可读性，甚至有时会提高可读性 123dog.moveUp(2);dog.moveLeft(3);Position position = dog.getPosition(); v.s. 1Position position = dog.moveUp(2).moveLeft(3).getPosition(); 可以省略一些临时变量 1234SomeObject someObject = new SomeObject(1, 2);someObject.moveUp(2);someObject.moveLeft(3);Position newPosition = someObject.getPosition(); v.s. 1234Position newPosition = new SomeObject() .moveUp(2) .moveLeft(3) .getPosition(); Cons 测试和 Debug 会变得复杂一些 当发生异常时，通常使用 stack trace 返回的 method call 和行号来定位错误 但使用 chianing method 的话就会难以准确定位到具体是哪一次调用出现了异常 1list.add(0).add(1).add(2).add(3); // 无法通过行号定位到错误 会使得返回另一个同类型对象的 API 与 fluent API 之间易被混淆 12345678// 函数签名，可以有两种解释方式MyBigInteger add(MyBigInteger another);// 1. 非 method chaining 风格，java.math.BigInteger 的做法。a 本身不发生变化，result 是一个新的值为 (a + b + c) * d 的 MyBigIntegerMyBigInteger result = a.add(b).add(c).mult(d);// 2. method chaining 风格。 a 发生变化，a 的值变为 a + b，即 a := (a + b + c) * da.add(b).add(c).mult(d); 一定程度上破坏了 . 运算符的原有语义 有人认为 . 运算符的语义本质上是 调用者.操作名 Chaining method 尽管语法上合规，但它隐藏了 调用者，一定程度上破坏了语义 一定程度上违背 CQRS (Command Query Responsibility Segregation) 总结 &amp; 个人选择 Method chaining 说到底只是一种编程风格，更多的讨论集中于这样子做自己能不能“写得爽”和别人能不能“看得懂”，无关乎性能（大部分情况下）。所以这个总结更多的还是一种我自己个人的喜好和总结。 Fluent interface 不能与 CQRS 风格的接口混用 使用 Method chaining 时，最好能在文档中特别注明，因为 CQRS 是更加直觉的 Method chaining 能简化代码中的一些重复内容 可能会增加一定的理解成本，但这是值得的 总之，我觉得 Method chaining 写起来爽而且并不需要很高的理解成本。","categories":[{"name":"SE","slug":"SE","permalink":"https://zinc0x1e.github.io/categories/SE/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://zinc0x1e.github.io/tags/Design-Pattern/"},{"name":"OOP","slug":"OOP","permalink":"https://zinc0x1e.github.io/tags/OOP/"}]},{"title":"element-ui 的 image-viewer 简单分析","slug":"img-viewer-of-element-ui","date":"2019-12-28T04:08:23.000Z","updated":"2021-03-13T08:32:27.323Z","comments":true,"path":"2019/12/28/img-viewer-of-element-ui/","link":"","permalink":"https://zinc0x1e.github.io/2019/12/28/img-viewer-of-element-ui/","excerpt":"","text":"element 组件 image-viewer 的简单分析 组件源代码详见此页面 这个组件作为 el-image 的附属, 相关内容没有写在 element 的文档里. 翻阅这个组件的代码主要是由于在项目过程中发现了一个奇怪的 bug: 在点击作为缩略图的 el-image 组件试图打开完整图片的时候, image-viewer 并不能显示 el-image 图片本身. Element 作为一个成熟的组件库，自然拥有图片放大预览像个的组件。这个组件提供的基本功能有： 渐入 / 渐出 放大 / 缩小 旋转 图片查看模式切换 切换图片 组件参数 先看调用这个组件时的参数 参数名 类型 默认值 描述 url-list Array ()=&gt;[] 希望在预览时可以通过左右箭头切换的图片的url列表 z-index Number 2000 on-switch Function ()=&gt;&#123;&#125; 图片切换时调用的函数 on-close Function ()=&gt;&#123;&#125; 关闭时调用的函数 initial-index Number 0 点开预览时，第一张图片在url-list中对应的下标 &nbsp;props 对象12345678910111213141516171819202122props: &#123; urlList: &#123; type: Array, default: () =&gt; [] &#125;, zIndex: &#123; type: Number, default: 2000 &#125;, onSwitch: &#123; type: Function, default: () =&gt; &#123;&#125; &#125;, onClose: &#123; type: Function, default: () =&gt; &#123;&#125; &#125;, initialIndex: &#123; type: Number, default: 0 &#125;&#125;, 这个组件在el-image内调用时使用的参数是： 1&lt;image-viewer :z-index=&quot;zIndex&quot; :initial-index=&quot;imageIndex&quot; v-show=&quot;showViewer&quot; :on-close=&quot;closeViewer&quot; :url-list=&quot;previewSrcList&quot;/&gt; previewSrcList来自于调用el-image输入的参数。 imageIndex在这里是用这个函数算出来的： 123imageIndex() &#123; return this.previewSrcList.indexOf(this.src);&#125; 也就是说，如果调用el-image时输入的previewSrcList没有el-image本身对应的图片，image-viewer被打开时是不会有任何图片被展示的。这点就很致命了，尤其是缩略图打开后预览高清图的情况。 图片相关的数据 当前图片的数据存放在data字段下的transform对象。 1234567transform: &#123; scale: 1, deg: 0, offsetX: 0, offsetY: 0, enableTransition: false&#125; 渐入渐出 调用的是viewer-fade, 不可定制 放大缩小/旋转 通过handleActions函数调用相关方法。 放大缩小 代码： 123456// 放大：transform.scale = parseFloat((transform.scale + zoomRate).toFixed(3));// 缩小：if (transform.scale &gt; 0.2) &#123; transform.scale = parseFloat((transform.scale - zoomRate).toFixed(3));&#125; 直接编辑图片展示的大小这个属性。 旋转 同样也是直接编辑transform对象下deg属性 1234// 逆时针: transform.deg += rotateDeg;// 顺时针: transform.deg -= rotateDeg; 动画 所有属性的更改都会涉及到这行代码： 1transition: enableTransition ? &#x27;transform .3s&#x27; : &#x27;&#x27;, 进而为属性的更改加上动画效果。 图片切换 调用prev()和next()函数完成 12345678910prev() &#123; if (this.isFirst &amp;&amp; !this.infinite) return; const len = this.urlList.length; this.index = (this.index - 1 + len) % len;&#125;,next() &#123; if (this.isLast &amp;&amp; !this.infinite) return; const len = this.urlList.length; this.index = (this.index + 1) % len;&#125;, 还蛮简单的，就不分析了。 图片模式切换 一共定义了两个模式CONTAIN和ORIGINAL CONTAIN模式会将图片全屏，ORIGINAL模式会显示原图大小 12345678910const Mode = &#123; CONTAIN: &#123; name: &#x27;contain&#x27;, icon: &#x27;el-icon-full-screen&#x27; &#125;, ORIGINAL: &#123; name: &#x27;original&#x27;, icon: &#x27;el-icon-c-scale-to-original&#x27; &#125;&#125;; 模式切换通过调用toggleMode()函数实现 123456789toggleMode() &#123; if (this.loading) return; const modeNames = Object.keys(Mode); const modeValues = Object.values(Mode); const index = modeValues.indexOf(this.mode); const nextIndex = (index + 1) % modeNames.length; this.mode = Mode[modeNames[nextIndex]]; this.reset();&#125; 如果要添加更多的模式，只需要在Mode对象下添加即可，不需要再修改其他的代码。 图片加载时的情形 这个组件维护了一个变量：loading，来标志是否在加载。加载失败或加载中的情况直接调用了img下的@load和@error来处理。 如果想要改变加载时展示的图片，最方便的做法是将&lt;template&gt;下的&lt;img&gt;换成&lt;el-image&gt;，再用el-image的相关插槽来改变","categories":[{"name":"frontend","slug":"frontend","permalink":"https://zinc0x1e.github.io/categories/frontend/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"https://zinc0x1e.github.io/tags/vue-js/"},{"name":"element","slug":"element","permalink":"https://zinc0x1e.github.io/tags/element/"}]}],"categories":[{"name":"database","slug":"database","permalink":"https://zinc0x1e.github.io/categories/database/"},{"name":"algorithm","slug":"algorithm","permalink":"https://zinc0x1e.github.io/categories/algorithm/"},{"name":"SE","slug":"SE","permalink":"https://zinc0x1e.github.io/categories/SE/"},{"name":"frontend","slug":"frontend","permalink":"https://zinc0x1e.github.io/categories/frontend/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://zinc0x1e.github.io/tags/Redis/"},{"name":"源码解析","slug":"源码解析","permalink":"https://zinc0x1e.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"字符串","slug":"字符串","permalink":"https://zinc0x1e.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://zinc0x1e.github.io/tags/Design-Pattern/"},{"name":"OOP","slug":"OOP","permalink":"https://zinc0x1e.github.io/tags/OOP/"},{"name":"vue.js","slug":"vue-js","permalink":"https://zinc0x1e.github.io/tags/vue-js/"},{"name":"element","slug":"element","permalink":"https://zinc0x1e.github.io/tags/element/"}]}